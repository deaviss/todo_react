import { INode, Type, IType, TypeFlags, IContext, IValidationResult, ObjectNode, IAnyType, ExtractT, IComplexType, IAnyStateTreeNode } from "../../internal";
export declare abstract class BaseReferenceType<T> extends Type<string | number | T, string | number, T> {
    protected readonly targetType: IType<any, any, T>;
    readonly shouldAttachNode: boolean;
    readonly flags: TypeFlags;
    constructor(targetType: IType<any, any, T>);
    describe(): string;
    isAssignableFrom(type: IAnyType): boolean;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
}
export declare class IdentifierReferenceType<T> extends BaseReferenceType<T> {
    constructor(targetType: IType<any, any, T>);
    getValue(node: INode): any;
    getSnapshot(node: INode): any;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: any): INode;
    reconcile(current: INode, newValue: any): INode;
}
export declare class CustomReferenceType<T> extends BaseReferenceType<T> {
    private readonly options;
    constructor(targetType: IType<any, any, T>, options: ReferenceOptions<T>);
    getValue(node: INode): T | undefined;
    getSnapshot(node: INode): any;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: any): INode;
    reconcile(current: INode, snapshot: any): INode;
}
export interface ReferenceOptions<T> {
    get(identifier: string | number, parent: IAnyStateTreeNode | null): T;
    set(value: T, parent: IAnyStateTreeNode | null): string | number;
}
export interface IReferenceType<IR extends IComplexType<any, any, any>> extends IType<string | number | ExtractT<IR>, string | number, ExtractT<IR>> {
    flags: TypeFlags.Reference;
}
/**
 * Creates a reference to another type, which should have defined an identifier.
 * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.
 *
 * @export
 * @alias types.reference
 */
export declare function reference<IT extends IComplexType<any, any, any>>(subType: IT, options?: ReferenceOptions<ExtractT<IT>>): IReferenceType<IT>;
export declare function isReferenceType<IT extends IReferenceType<any>>(type: IT): type is IT;
