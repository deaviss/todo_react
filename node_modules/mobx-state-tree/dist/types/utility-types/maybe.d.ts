import { IType, TypeFlags, IComplexType, IAnyType, ExtractC, ExtractS, ExtractT, IReferenceType } from "../../internal";
export declare type IMaybeTypeBase<IT extends IAnyType, C, O> = IT extends IReferenceType<infer IR> ? IComplexType<ExtractC<IR> | ExtractC<IT> | C, ExtractS<IR> | O, ExtractT<IR> | O> & {
    flags: TypeFlags.Optional;
} : IT extends IComplexType<any, any, any> ? IComplexType<ExtractC<IT> | C, ExtractS<IT> | O, ExtractT<IT> | O> & {
    flags: TypeFlags.Optional;
} : IT extends IAnyType ? IType<ExtractC<IT> | C, ExtractS<IT> | O, ExtractT<IT> | O> & {
    flags: TypeFlags.Optional;
} : never;
export declare type IMaybeType<IT extends IAnyType> = IMaybeTypeBase<IT, undefined, undefined>;
/**
 * Maybe will make a type nullable, and also optional.
 * The value `undefined` will be used to represent nullability.
 *
 * @export
 * @alias types.maybe
 * @template C
 * @template S
 * @template T
 * @param {IType<C, S, M>} type The type to make nullable
 * @returns {(IType<C | undefined, S | undefined, T | undefined>)}
 */
export declare function maybe<IT extends IAnyType>(type: IT): IMaybeType<IT>;
export declare type IMaybeNullType<IT extends IAnyType> = IMaybeTypeBase<IT, null | undefined, null>;
/**
 * Maybe will make a type nullable, and also optional.
 * The value `null` will be used to represent no value.
 *
 * @export
 * @alias types.maybeNull
 * @template C
 * @template S
 * @template T
 * @param {IType<C, S, M>} type The type to make nullable
 * @returns {(IType<C | null | undefined, S | null, T | null>)}
 */
export declare function maybeNull<IT extends IAnyType>(type: IT): IMaybeNullType<IT>;
