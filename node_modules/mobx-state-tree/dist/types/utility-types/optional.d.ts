import { INode, Type, IType, TypeFlags, IContext, IValidationResult, IAnyType, IComplexType } from "../../internal";
export declare type IFunctionReturn<T> = () => T;
export declare type IOptionalValue<C, S, T> = C | S | T | IFunctionReturn<C | S | T>;
export declare class OptionalValue<C, S, T> extends Type<C, S, T> {
    readonly type: IType<C, S, T>;
    readonly defaultValue: IOptionalValue<C, S, T>;
    readonly flags: number;
    readonly shouldAttachNode: boolean;
    constructor(type: IType<C, S, T>, defaultValue: IOptionalValue<C, S, T>);
    describe(): string;
    instantiate(parent: INode, subpath: string, environment: any, value: S): INode;
    reconcile(current: INode, newValue: any): INode;
    private getDefaultValue;
    getDefaultValueSnapshot(): any;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    isAssignableFrom(type: IAnyType): boolean;
}
export declare function optional<C, S, T>(type: IComplexType<C, S, T>, defaultValueOrFunction: C | S | T): IComplexType<C | undefined, S, T> & {
    flags: TypeFlags.Optional;
};
export declare function optional<C, S, T>(type: IComplexType<C, S, T>, defaultValueOrFunction: () => C | S | T): IComplexType<C | undefined, S, T> & {
    flags: TypeFlags.Optional;
};
export declare function optional<C, S, T>(type: IType<C, S, T>, defaultValueOrFunction: C | S | T): IType<C | undefined, S, T> & {
    flags: TypeFlags.Optional;
};
export declare function optional<C, S, T>(type: IType<C, S, T>, defaultValueOrFunction: () => C | S | T): IType<C | undefined, S, T> & {
    flags: TypeFlags.Optional;
};
export declare function isOptionalType<IT extends IType<any | undefined, any, any> & {
    flags: TypeFlags.Optional;
}>(type: IT): type is IT;
