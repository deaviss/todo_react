import { IObjectWillChange } from "mobx";
import { IStateTreeNode, IJsonPatch, INode, ComplexType, IComplexType, IType, TypeFlags, IContext, IValidationResult, ObjectNode, IChildNodesMap, IAnyType, ExtractIStateTreeNode } from "../../internal";
export declare enum HookNames {
    afterCreate = "afterCreate",
    afterAttach = "afterAttach",
    beforeDetach = "beforeDetach",
    beforeDestroy = "beforeDestroy"
}
export interface ModelProperties {
    [key: string]: IAnyType;
}
export declare type ModelPrimitive = string | number | boolean | Date;
export interface ModelPropertiesDeclaration {
    [key: string]: ModelPrimitive | IAnyType;
}
/**
 * Unmaps syntax property declarations to a map of { propName: IType }
 */
export declare type ModelPropertiesDeclarationToProperties<T extends ModelPropertiesDeclaration> = {
    [K in keyof T]: T[K] extends string ? IType<string | undefined, string, string> & {
        flags: TypeFlags.Optional;
    } : T[K] extends number ? IType<number | undefined, number, number> & {
        flags: TypeFlags.Optional;
    } : T[K] extends boolean ? IType<boolean | undefined, boolean, boolean> & {
        flags: TypeFlags.Optional;
    } : T[K] extends Date ? IType<number | Date | undefined, number, Date> & {
        flags: TypeFlags.Optional;
    } : T[K] extends IAnyType ? T[K] : never;
};
export interface OptionalPropertyTypes {
    flags: TypeFlags.Optional;
}
export declare type RequiredPropNames<T> = {
    [K in keyof T]: T[K] extends OptionalPropertyTypes ? never : K;
}[keyof T];
export declare type OptionalPropNames<T> = {
    [K in keyof T]: T[K] extends OptionalPropertyTypes ? K : never;
}[keyof T];
export declare type RequiredProps<T> = Pick<T, RequiredPropNames<T>>;
export declare type OptionalProps<T> = Pick<T, OptionalPropNames<T>>;
/**
 * Maps property types to the snapshot, including omitted optional attributes
 */
export declare type ModelCreationType<T extends ModelPropertiesDeclarationToProperties<any>> = {
    [K in keyof RequiredProps<T>]: T[K] extends IType<infer C, any, any> ? C : never;
} & {
    [K in keyof OptionalProps<T>]?: T[K] extends IType<infer C, any, any> ? C : never;
};
export declare type ModelSnapshotType<T extends ModelPropertiesDeclarationToProperties<any>> = {
    [K in keyof T]: T[K] extends IType<any, infer S, any> ? S : never;
};
export declare type ModelInstanceType<T extends ModelPropertiesDeclarationToProperties<any>, O, C, S> = {
    [K in keyof T]: T[K] extends IType<infer C, infer S, infer M> ? ExtractIStateTreeNode<T[K], C, S, M> : never;
} & O & IStateTreeNode<C, S>;
export interface ModelActions {
    [key: string]: Function;
}
export interface IModelType<PROPS extends ModelProperties, OTHERS, C = ModelCreationType<PROPS>, S = ModelSnapshotType<PROPS>, T = ModelInstanceType<PROPS, OTHERS, C, S>> extends IComplexType<C, S, T> {
    readonly properties: PROPS;
    named(newName: string): this;
    props<PROPS2 extends ModelPropertiesDeclaration>(props: PROPS2): IModelType<PROPS & ModelPropertiesDeclarationToProperties<PROPS2>, OTHERS>;
    views<V extends Object>(fn: (self: ModelInstanceType<PROPS, OTHERS, C, S>) => V): IModelType<PROPS, OTHERS & V>;
    actions<A extends ModelActions>(fn: (self: ModelInstanceType<PROPS, OTHERS, C, S>) => A): IModelType<PROPS, OTHERS & A>;
    volatile<TP extends object>(fn: (self: ModelInstanceType<PROPS, OTHERS, C, S>) => TP): IModelType<PROPS, OTHERS & TP>;
    extend<A extends ModelActions = {}, V extends Object = {}, VS extends Object = {}>(fn: (self: ModelInstanceType<PROPS, OTHERS, C, S>) => {
        actions?: A;
        views?: V;
        state?: VS;
    }): IModelType<PROPS, OTHERS & A & V & VS>;
    preProcessSnapshot<S0 = ModelCreationType<PROPS>>(fn: (snapshot: S0) => ModelCreationType<PROPS>): IModelType<PROPS, OTHERS, S0>;
    postProcessSnapshot<S1 = ModelCreationType<PROPS>>(fn: (snapshot: ModelSnapshotType<PROPS>) => S1): IModelType<PROPS, OTHERS, S1>;
}
export interface ModelTypeConfig {
    name?: string;
    properties?: ModelProperties;
    initializers?: ReadonlyArray<((instance: any) => any)>;
    preProcessor?: (snapshot: any) => any;
    postProcessor?: (snapshot: any) => any;
}
export declare class ModelType<S extends ModelProperties, T> extends ComplexType<any, any, any> implements IModelType<S, T> {
    readonly flags: TypeFlags;
    shouldAttachNode: boolean;
    readonly identifierAttribute: string | undefined;
    readonly initializers: ((instance: any) => any)[];
    readonly properties: any;
    private preProcessor;
    private postProcessor;
    private readonly propertyNames;
    constructor(opts: ModelTypeConfig);
    private _getIdentifierAttribute;
    cloneAndEnhance(opts: ModelTypeConfig): ModelType<any, any>;
    actions(fn: (self: any) => any): any;
    instantiateActions(self: T, actions: any): void;
    named(name: string): this;
    props(properties: ModelPropertiesDeclaration): any;
    volatile(fn: (self: any) => any): any;
    instantiateVolatileState(self: T, state: Object): void;
    extend(fn: (self: any) => any): any;
    views(fn: (self: any) => any): any;
    instantiateViews(self: T, views: Object): void;
    preProcessSnapshot(preProcessor: (snapshot: any) => any): any;
    postProcessSnapshot(postProcessor: (snapshot: any) => any): any;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: any): INode;
    initializeChildNodes(objNode: ObjectNode, initialSnapshot?: any): IChildNodesMap;
    createNewInstance(): Object;
    finalizeNewInstance(node: INode, childNodes: IChildNodesMap): void;
    willChange(change: any): IObjectWillChange | null;
    didChange(change: any): void;
    getChildren(node: ObjectNode): INode[];
    getChildNode(node: ObjectNode, key: string): INode;
    getValue(node: ObjectNode): any;
    getSnapshot(node: ObjectNode, applyPostProcess?: boolean): any;
    applyPatchLocally(node: ObjectNode, subpath: string, patch: IJsonPatch): void;
    applySnapshot(node: ObjectNode, snapshot: any): void;
    applySnapshotPreProcessor(snapshot: any): any;
    applySnapshotPostProcessor(snapshot: any): any;
    getChildType(key: string): IAnyType;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    private forAllProps;
    describe(): string;
    getDefaultSnapshot(): any;
    removeChild(node: ObjectNode, subpath: string): void;
}
export declare function model<T extends ModelPropertiesDeclaration = {}>(name: string, properties?: T): IModelType<ModelPropertiesDeclarationToProperties<T>, {}>;
export declare function model<T extends ModelPropertiesDeclaration = {}>(properties?: T): IModelType<ModelPropertiesDeclarationToProperties<T>, {}>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>): IModelType<T1 & T2, S1 & S2>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>): IModelType<T1 & T2 & T3, S1 & S2 & S3>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>): IModelType<T1 & T2 & T3 & T4, S1 & S2 & S3 & S4>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>): IModelType<T1 & T2 & T3 & T4 & T5, S1 & S2 & S3 & S4 & S5>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>): IModelType<T1 & T2 & T3 & T4 & T5 & T6, S1 & S2 & S3 & S4 & S5 & S6>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7, S1 & S2 & S3 & S4 & S5 & S6 & S7>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8, T9 extends ModelProperties, S9>(name: string, t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>, t9: IModelType<T9, S9>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8 & T9, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>): IModelType<T1 & T2, S1 & S2>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>): IModelType<T1 & T2 & T3, S1 & S2 & S3>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>): IModelType<T1 & T2 & T3 & T4, S1 & S2 & S3 & S4>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>): IModelType<T1 & T2 & T3 & T4 & T5, S1 & S2 & S3 & S4 & S5>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>): IModelType<T1 & T2 & T3 & T4 & T5 & T6, S1 & S2 & S3 & S4 & S5 & S6>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7, S1 & S2 & S3 & S4 & S5 & S6 & S7>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8, T9 extends ModelProperties, S9>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>, t9: IModelType<T9, S9>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8 & T9, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9>;
export declare function isModelType<IT extends IModelType<any, any>>(type: IT): type is IT;
